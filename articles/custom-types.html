<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Custom types • torchexport</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Custom types">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">torchexport</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.0.1.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/behind_the_scenes.html">torchexport: Behind the scenes</a></li>
    <li><a class="dropdown-item" href="../articles/custom-types.html">Custom types</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/mlverse/torchexport/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Custom types</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/mlverse/torchexport/blob/main/vignettes/articles/custom-types.Rmd" class="external-link"><code>vignettes/articles/custom-types.Rmd</code></a></small>
      <div class="d-none name"><code>custom-types.Rmd</code></div>
    </div>

    
    
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/mlverse/torchexport" class="external-link">torchexport</a></span><span class="op">)</span></span></code></pre></div>
<p>When extending torch with C++, you might want your C++ function to
return types that are not defined in <a href="https://github.com/mlverse/torch/blob/93b250ae48911f572d5477e8f52b19c40a5da86c/inst/include/torch_types.h#L659-L763" class="external-link">torch.h</a>,
or ones where no automatic casting from and to <code>raw</code> pointers
has yet been implemented in <a href="https://github.com/mlverse/torch/blob/93b250ae48911f572d5477e8f52b19c40a5da86c/lantern/include/lantern/types.h#L50-L113" class="external-link">lantern/types.h</a>.
<code>torchexport</code> can be extended to support custom types defined
in user packages, provided that you implement all the necessary
casting:</p>
<ul>
<li>
<code>frow_raw</code> and <code>make_raw</code> : On the
<code>csrc</code> side, you must specify how your type is to be
converted to a <code>void*</code> pointer, as well as how to convert
from <code>void*</code> to your custom type. Note that for C structs,
you can also directly return the object without casting them to a
<code>void*</code>. In such cases you can define these types in the
<code>csrc/include/&lt;package&gt;/common.h</code> file. If this file
exists, you will also have access to these types on the Rcpp side.</li>
<li>
<code>Rcpp</code> type: On the Rcpp side ,you need to implement the
casting between <code>void*</code> and a custom Rcpp type that can
manage the memory pointed by this <code>void*</code>.</li>
<li>Rcpp type to <code>SEXP</code>: if you ever return this type to R
(as opposed to only using it in Rcpp) you need to implement casting from
the Rcpp custom type to a <code>SEXP</code>.</li>
<li>
<code>SEXP</code> to Rcpp type: if you use this type as an argument
on the R side, you must implement the casting from <code>SEXP</code> to
your custom type.</li>
</ul>
<div class="section level2">
<h2 id="example">Example<a class="anchor" aria-label="anchor" href="#example"></a>
</h2>
<p>In this example we will implement the <code>tensor_pair</code> type,
an alias for
<code>std::tuple&lt;torch::Tensor, torch::Tensor&gt;</code>. This type
is not implemented in <code>torch</code>, thus we need to implement it
ourselves. In fact, this type was needed in the <a href="https://github.com/mlverse/torchsparse" class="external-link">torchsparse</a> package;
that’s why the names of the files will sometimes start with
<code>torchsparse_</code>.</p>
<div class="section level3">
<h3 id="the-csrc-side">The <code>csrc</code> side<a class="anchor" aria-label="anchor" href="#the-csrc-side"></a>
</h3>
<p>First we will create a file called <code>torchparse_types.h</code> in
the <code>csrc/include/torchsparse</code> directory. This file will
contain the declaration of your custom type and the declarations for the
functions that allows casting this type to and from <code>void*</code>
pointers.</p>
<p>For example, it can look like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;torch/torch.h&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a><span class="co">// declares the alias, but could also be a `class CustomType`.</span></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a><span class="kw">using</span> tensor_pair <span class="op">=</span> <span class="bu">std::</span>tuple<span class="op">&lt;</span>torch<span class="op">::</span>Tensor<span class="op">,</span>torch<span class="op">::</span>Tensor<span class="op">&gt;;</span></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a><span class="co">// In this namespace we declare the function that creates a `void*`</span></span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a><span class="co">// from an instance of your type. This `void*` pointer must own all</span></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a><span class="co">// its memory.</span></span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a><span class="kw">namespace</span> make_raw <span class="op">{</span></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a>  <span class="dt">void</span><span class="op">*</span> TensorPair <span class="op">(</span><span class="at">const</span> tensor_pair<span class="op">&amp;</span> x<span class="op">);</span></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a><span class="co">// In this namespace we declare a function that takes a void* pointer and</span></span>
<span id="cb2-14"><a href="#cb2-14" tabindex="-1"></a><span class="co">// returns a reference to your type. It's a good idea to return by </span></span>
<span id="cb2-15"><a href="#cb2-15" tabindex="-1"></a><span class="co">// reference.</span></span>
<span id="cb2-16"><a href="#cb2-16" tabindex="-1"></a><span class="kw">namespace</span> from_raw <span class="op">{</span></span>
<span id="cb2-17"><a href="#cb2-17" tabindex="-1"></a>  tensor_pair<span class="op">&amp;</span> TensorPair <span class="op">(</span><span class="dt">void</span><span class="op">*</span> x<span class="op">);</span></span>
<span id="cb2-18"><a href="#cb2-18" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Now that we declared the type and it’s casting functions, we will
implement these functions. The name of the file doesn’t matter here, but
it’s nice to use <code>torchsparse_types.cpp</code>. This file lives in
<code>csrc/src</code>. Don’t forget to add it to the
<code>CMakeLists.txt</code> file so it also gets compiled.</p>
<p>The implementation of <code>make_raw::TensorPair</code> and
<code>from_raw::TensorPair</code> look like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;torch/torch.h&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="pp">#include </span><span class="im">"torchsparse/torchsparse_types.h"</span></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;torchsparse/sparse.h&gt;</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;lantern/types.h&gt;</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a><span class="kw">namespace</span> make_raw <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a><span class="co">// This is mostly the same as:</span></span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a><span class="co">// return (void*) new tensor_pair(x); </span></span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a><span class="co">// but in a fancy C++ way.</span></span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a><span class="dt">void</span><span class="op">*</span> TensorPair <span class="op">(</span><span class="at">const</span> tensor_pair<span class="op">&amp;</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a>  <span class="cf">return</span> make_ptr<span class="op">&lt;</span>tensor_pair<span class="op">&gt;(</span>x<span class="op">);</span></span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-15"><a href="#cb3-15" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" tabindex="-1"></a><span class="co">// This simply tells the compiler to consider that `void*` is a pointer to</span></span>
<span id="cb3-17"><a href="#cb3-17" tabindex="-1"></a><span class="co">// `tensor_pair` and then returns this reference.</span></span>
<span id="cb3-18"><a href="#cb3-18" tabindex="-1"></a><span class="kw">namespace</span> from_raw <span class="op">{</span></span>
<span id="cb3-19"><a href="#cb3-19" tabindex="-1"></a>tensor_pair<span class="op">&amp;</span> TensorPair <span class="op">(</span><span class="dt">void</span><span class="op">*</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-20"><a href="#cb3-20" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">*</span><span class="kw">reinterpret_cast</span><span class="op">&lt;</span>tensor_pair<span class="op">*&gt;(</span>x<span class="op">);</span></span>
<span id="cb3-21"><a href="#cb3-21" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-22"><a href="#cb3-22" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-23"><a href="#cb3-23" tabindex="-1"></a></span>
<span id="cb3-24"><a href="#cb3-24" tabindex="-1"></a><span class="co">// ---- there's more.</span></span></code></pre></div>
<p>Additionally in this file we will implement functions that will allow
us to free the memory pointed by this pointer, as well as tools to help
us cast this type to something that we can return to R.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="co">// Takes a void* pointer and deletes the memory it points to.</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="co">// First need to cast to the correct type.</span></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="co">// [[torch::export]]</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a><span class="dt">void</span> delete_tensor_pair<span class="op">(</span><span class="dt">void</span><span class="op">*</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>  <span class="kw">delete</span> <span class="kw">reinterpret_cast</span><span class="op">&lt;</span>tensor_pair<span class="op">*&gt;(</span>x<span class="op">);</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a><span class="co">// Extract a single Tensor from this type. This will allow us to</span></span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a><span class="co">// convert this type into a list of tensors to pass to R.</span></span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a><span class="co">// [[torch::export]]</span></span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a>torch<span class="op">::</span>Tensor tensor_pair_get_first<span class="op">(</span>tensor_pair x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-13"><a href="#cb4-13" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>x<span class="op">);</span></span>
<span id="cb4-14"><a href="#cb4-14" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-15"><a href="#cb4-15" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" tabindex="-1"></a><span class="co">// [[torch::export]]</span></span>
<span id="cb4-17"><a href="#cb4-17" tabindex="-1"></a>torch<span class="op">::</span>Tensor tensor_pair_get_second<span class="op">(</span>tensor_pair x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-18"><a href="#cb4-18" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;(</span>x<span class="op">);</span></span>
<span id="cb4-19"><a href="#cb4-19" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We are done with the type implementation on the <code>csrc</code>
side. We can now implement a function that uses this type. For
example:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="co">// [[torch::export(register_types=c("tensor_pair", "TensorPair", "void*", "torchsparse::tensor_pair"))]]</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>tensor_pair sparse_relabel<span class="op">(</span>torch<span class="op">::</span>Tensor col<span class="op">,</span> torch<span class="op">::</span>Tensor idx<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>  <span class="cf">return</span> relabel<span class="op">(</span>col<span class="op">,</span> idx<span class="op">);</span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note the arguments in the <code>// [[torch::export]]</code> special
comment. Here we are telling <code>torchexport</code> what to generate.
Namely, on encountering the type
<strong><code>tensor_pair</code></strong> (first argument), it
should:</p>
<ul>
<li>Use <code>make_raw::TensorPair</code> and
<code>from_raw::TensorPair</code> to cast between <code>void*</code> and
<code>tensor_pair</code>. (<code>TensorPair</code> is the second
argument.)</li>
<li>Use <code>void*</code> as the C type. In general it will always be
<code>void*</code> here, unless you can cast to another C type and still
re-create the object. (<code>void*</code> is the third argument.)</li>
<li>Use <code>torchsparse::tensor_pair</code> as the Rcpp type.
(<code>torchsparse::tensor_pair</code> is the third argument.) This we
haven’t implemented yet; it’ll be our next step.</li>
</ul>
<p><strong>Note</strong>: You only need to register the type once, for a
single function that uses it. If we want to export other functions that
return <code>tensor_pair</code> we won’t need to register the type again
in the <code>[[torch::export]]</code> comment.</p>
<p>We can now <code>cmake --build . --target install --parallel 8</code>
to compile the <code>csrc</code> library, and everything should go
fine.</p>
</div>
<div class="section level3">
<h3 id="the-rcpp-side">The <code>Rcpp</code> side<a class="anchor" aria-label="anchor" href="#the-rcpp-side"></a>
</h3>
<p>Now, on to the Rcpp side. We need to implement the custom Rcpp type
that will hold the <code>void*</code> pointer returned from the
<code>csrc</code> side, take care of the corresponding memory, and cast
to <code>SEXP</code> when needed.</p>
<p>First we declare this type in
<code>src/torchsparse_types.h</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="pp">#pragma once</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;torch.h&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="kw">namespace</span> torchsparse <span class="op">{</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="kw">class</span> tensor_pair <span class="op">{</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>  <span class="co">// this is the slot to hold the void*</span></span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>  <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;</span> ptr<span class="op">;</span></span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>  <span class="co">// the constructor from a void*</span></span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a>  tensor_pair <span class="op">(</span><span class="dt">void</span><span class="op">*</span> x<span class="op">);</span></span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a>  <span class="co">// casting operator Rcpp-&gt;SEXP</span></span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a>  <span class="kw">operator</span> SEXP <span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb6-14"><a href="#cb6-14" tabindex="-1"></a>  <span class="co">// returns the void* from the type.</span></span>
<span id="cb6-15"><a href="#cb6-15" tabindex="-1"></a>  <span class="dt">void</span><span class="op">*</span> get <span class="op">();</span></span>
<span id="cb6-16"><a href="#cb6-16" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb6-17"><a href="#cb6-17" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The type having been declared, we can now implement its member
functions in <code>src/torchsparse_types.cpp</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;Rcpp.h&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="pp">#include </span><span class="im">"torchsparse_types.h"</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a><span class="pp">#include </span><span class="im">"exports.h"</span></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a><span class="kw">namespace</span> torchsparse <span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a><span class="dt">void</span><span class="op">*</span> tensor_pair<span class="op">::</span>get<span class="op">()</span> <span class="op">{</span></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a>  <span class="cf">return</span> ptr<span class="op">.</span>get<span class="op">();</span></span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a><span class="co">// Creates a list of two torch::Tensor's from this object.</span></span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a>tensor_pair<span class="op">::</span><span class="kw">operator</span> SEXP <span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a>  Rcpp<span class="op">::</span>List out<span class="op">;</span></span>
<span id="cb7-14"><a href="#cb7-14" tabindex="-1"></a>  out<span class="op">.</span>push_back<span class="op">(</span>rcpp_tensor_pair_get_first<span class="op">(*</span><span class="kw">this</span><span class="op">));</span></span>
<span id="cb7-15"><a href="#cb7-15" tabindex="-1"></a>  out<span class="op">.</span>push_back<span class="op">(</span>rcpp_tensor_pair_get_second<span class="op">(*</span><span class="kw">this</span><span class="op">));</span></span>
<span id="cb7-16"><a href="#cb7-16" tabindex="-1"></a>  <span class="cf">return</span> out<span class="op">;</span></span>
<span id="cb7-17"><a href="#cb7-17" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-18"><a href="#cb7-18" tabindex="-1"></a></span>
<span id="cb7-19"><a href="#cb7-19" tabindex="-1"></a><span class="co">// initialize the `ptr` slot and **very important** register the custom</span></span>
<span id="cb7-20"><a href="#cb7-20" tabindex="-1"></a><span class="co">// deleter `rcpp_delete_tensor_pair` that will free the pointer's memory</span></span>
<span id="cb7-21"><a href="#cb7-21" tabindex="-1"></a><span class="co">// once `ptr` is gone (and hence once the `torchsparse::tensor_pair` instance</span></span>
<span id="cb7-22"><a href="#cb7-22" tabindex="-1"></a><span class="co">// is gone).</span></span>
<span id="cb7-23"><a href="#cb7-23" tabindex="-1"></a>tensor_pair<span class="op">::</span>tensor_pair <span class="op">(</span><span class="dt">void</span><span class="op">*</span> x<span class="op">)</span> <span class="op">:</span> ptr<span class="op">(</span>x<span class="op">,</span> rcpp_delete_tensor_pair<span class="op">)</span> <span class="op">{};</span></span>
<span id="cb7-24"><a href="#cb7-24" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>You should now be able to <code>devtools::load_all()</code> and call
<code>rcpp_sparse_relabel()</code>. This function will return a list
with two <code>torch</code> Tensors.</p>
<p>In this case, we don’t need to provide functionality for casting from
a <code>SEXP</code> to the Rcpp type. If we had to, we’d have to
implement the <code>tensor_pair::tensor_pair (SEXP x)</code>
constructor, and probably have a function similar to
<code>rcpp_tensor_pair_get_first</code>, but doing things the other way
around: i.e., taking two <code>torch</code> Tensors and returning a
<code>tensor_pair</code>.</p>
<p>Finally, this tutorial is more like a set of notes (from when I was
implementing that functionality in <code>torchsparse</code>) than a
“tutorial”. Please open an issue if something is not clear, and we will
be very happy to help!</p>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Daniel Falbel.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
