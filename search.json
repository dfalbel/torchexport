[{"path":"https://mlverse.github.io/torchexport/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 torchexport authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://mlverse.github.io/torchexport/articles/custom-types.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Custom types","text":"example implement tensor_pair type, alias std::tuple<torch::Tensor, torch::Tensor>. type implemented torch, thus need implement . fact, type needed torchsparse package; ’s names files sometimes start torchsparse_.","code":""},{"path":"https://mlverse.github.io/torchexport/articles/custom-types.html","id":"the-csrc-side","dir":"Articles","previous_headings":"Example","what":"The csrc side","title":"Custom types","text":"First create file called torchparse_types.h csrc/include/torchsparse directory. file contain declaration custom type declarations functions allows casting type void* pointers. example, can look like : Now declared type ’s casting functions, implement functions. name file doesn’t matter , ’s nice use torchsparse_types.cpp. file lives csrc/src. Don’t forget add CMakeLists.txt file also gets compiled. implementation make_raw::TensorPair from_raw::TensorPair look like : Additionally file implement functions allow us free memory pointed pointer, well tools help us cast type something can return R. done type implementation csrc side. can now implement function uses type. example: Note arguments // [[torch::export]] special comment. telling torchexport generate. Namely, encountering type tensor_pair (first argument), : Use make_raw::TensorPair from_raw::TensorPair cast void* tensor_pair. (TensorPair second argument.) Use void* C type. general always void* , unless can cast another C type still re-create object. (void* third argument.) Use torchsparse::tensor_pair Rcpp type. (torchsparse::tensor_pair third argument.) haven’t implemented yet; ’ll next step. Note: need register type , single function uses . want export functions return tensor_pair won’t need register type [[torch::export]] comment. can now cmake --build . --target install --parallel 8 compile csrc library, everything go fine.","code":"#include <torch/torch.h>  // declares the alias, but could also be a `class CustomType`. using tensor_pair = std::tuple<torch::Tensor,torch::Tensor>;  // In this namespace we declare the function that creates a `void*` // from an instance of your type. This `void*` pointer must own all // its memory. namespace make_raw {   void* TensorPair (const tensor_pair& x); }  // In this namespace we declare a function that takes a void* pointer and // returns a reference to your type. It's a good idea to return by  // reference. namespace from_raw {   tensor_pair& TensorPair (void* x); } #include <torch/torch.h> #include \"torchsparse/torchsparse_types.h\" #include <torchsparse/sparse.h> #include <lantern/types.h>  namespace make_raw {  // This is mostly the same as: // return (void*) new tensor_pair(x);  // but in a fancy C++ way. void* TensorPair (const tensor_pair& x) {   return make_ptr<tensor_pair>(x); } }  // This simply tells the compiler to consider that `void*` is a pointer to // `tensor_pair` and then returns this reference. namespace from_raw { tensor_pair& TensorPair (void* x) {   return *reinterpret_cast<tensor_pair*>(x); } }  // ---- there's more. // Takes a void* pointer and deletes the memory it points to. // First need to cast to the correct type. // [[torch::export]] void delete_tensor_pair(void* x) {   delete reinterpret_cast<tensor_pair*>(x); }  // Extract a single Tensor from this type. This will allow us to // convert this type into a list of tensors to pass to R.  // [[torch::export]] torch::Tensor tensor_pair_get_first(tensor_pair x) {   return std::get<0>(x); }  // [[torch::export]] torch::Tensor tensor_pair_get_second(tensor_pair x) {   return std::get<1>(x); } // [[torch::export(register_types=c(\"tensor_pair\", \"TensorPair\", \"void*\", \"torchsparse::tensor_pair\"))]] tensor_pair sparse_relabel(torch::Tensor col, torch::Tensor idx) {   return relabel(col, idx); }"},{"path":"https://mlverse.github.io/torchexport/articles/custom-types.html","id":"the-rcpp-side","dir":"Articles","previous_headings":"Example","what":"The Rcpp side","title":"Custom types","text":"Now, Rcpp side. need implement custom Rcpp type hold void* pointer returned csrc side, take care corresponding memory, cast SEXP needed. First declare type src/torchsparse_types.h: type declared, can now implement member functions src/torchsparse_types.cpp: now able devtools::load_all() call rcpp_sparse_relabel(). function return list two torch Tensors. case, don’t need provide functionality casting SEXP Rcpp type. , ’d implement tensor_pair::tensor_pair (SEXP x) constructor, probably function similar rcpp_tensor_pair_get_first, things way around: .e., taking two torch Tensors returning tensor_pair. Finally, tutorial like set notes (implementing functionality torchsparse) “tutorial”. Please open issue something clear, happy help!","code":"#pragma once #include <torch.h>  namespace torchsparse {  class tensor_pair { public:   // this is the slot to hold the void*   std::shared_ptr<void> ptr;   // the constructor from a void*   tensor_pair (void* x);   // casting operator Rcpp->SEXP   operator SEXP () const;   // returns the void* from the type.   void* get (); };  } #include <Rcpp.h> #include \"torchsparse_types.h\" #include \"exports.h\"  namespace torchsparse {  void* tensor_pair::get() {   return ptr.get(); }  // Creates a list of two torch::Tensor's from this object. tensor_pair::operator SEXP () const {   Rcpp::List out;   out.push_back(rcpp_tensor_pair_get_first(*this));   out.push_back(rcpp_tensor_pair_get_second(*this));   return out; }  // initialize the `ptr` slot and **very important** register the custom // deleter `rcpp_delete_tensor_pair` that will free the pointer's memory // once `ptr` is gone (and hence once the `torchsparse::tensor_pair` instance // is gone). tensor_pair::tensor_pair (void* x) : ptr(x, rcpp_delete_tensor_pair) {};  }"},{"path":"https://mlverse.github.io/torchexport/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Daniel Falbel. Author, maintainer.","code":""},{"path":"https://mlverse.github.io/torchexport/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Falbel D (2022). torchexport: Code Generation 'C++' Interfaces 'torch'.. R package version 0.0.1.9000, https://github.com/mlverse/torchexport.","code":"@Manual{,   title = {torchexport: Code Generation for 'C++' Interfaces for 'torch'.},   author = {Daniel Falbel},   year = {2022},   note = {R package version 0.0.1.9000},   url = {https://github.com/mlverse/torchexport}, }"},{"path":"https://mlverse.github.io/torchexport/index.html","id":"torchexport","dir":"","previous_headings":"","what":"Code Generation for C++ Interfaces for torch.","title":"Code Generation for C++ Interfaces for torch.","text":"goal torchexport generate code handle errors common caveats writing C++ extensions torch. general, won’t need use package directly ’s called automatically template CMake file.","code":""},{"path":"https://mlverse.github.io/torchexport/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Code Generation for C++ Interfaces for torch.","text":"can install development version torchexport GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"dfalbel/torchexport\")"},{"path":"https://mlverse.github.io/torchexport/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Code Generation for C++ Interfaces for torch.","text":"Annotate function want export [[ torch::export ]]: Calling torchexport::export() generate csrc/src/exports.cpp csrc/include/<<NAME>>/exports.h definitions correctly handle cross-compile exceptions well import/export declarations.","code":"// [[ torch::export ]] void* c_lltm_forward(void* input,                      void* weights,                      void* bias,                      void* old_h,                      void* old_cell) {   return make_raw::TensorList(lltm_forward(       from_raw::Tensor(input),       from_raw::Tensor(weights),       from_raw::Tensor(bias),       from_raw::Tensor(old_h),       from_raw::Tensor(old_cell)   )); }"},{"path":"https://mlverse.github.io/torchexport/reference/export.html","id":null,"dir":"Reference","previous_headings":"","what":"Generates code that exports code from C++ extensions — export","title":"Generates code that exports code from C++ extensions — export","text":"function used CmakeList.txt file template autogenerate headers declarations exported functions torch C++ extensions.","code":""},{"path":"https://mlverse.github.io/torchexport/reference/export.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generates code that exports code from C++ extensions — export","text":"","code":"export(path = pkg_path())"},{"path":"https://mlverse.github.io/torchexport/reference/export.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generates code that exports code from C++ extensions — export","text":"path Path package, within package.","code":""}]
